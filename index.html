<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/01/hello-world/" class="article-date">
  <time datetime="2020-09-01T08:43:17.628Z" itemprop="datePublished">2020-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/01/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/01/hello-world/" data-id="ckejpjim10000mgzx7tge4x4r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java8中的流式写法的一点思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/01/java8%E4%B8%AD%E7%9A%84%E6%B5%81%E5%BC%8F%E5%86%99%E6%B3%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/" class="article-date">
  <time datetime="2020-08-31T16:00:00.000Z" itemprop="datePublished">2020-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java8/">Java8</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java8中的流式写法的一点思考"><a href="#java8中的流式写法的一点思考" class="headerlink" title="java8中的流式写法的一点思考"></a>java8中的流式写法的一点思考</h1><p>最近学习了java8实战和effective java这两本书关于流式写法的知识，在看完java8之后就在想流式写法肯定也会有它的缺点，它优化了外部迭代就肯定舍弃了什么，当学习到effective java 的时候我知道了它的缺点到底是什么。<br><code>Stream流式表达的优缺点是什么</code></p>
<ul>
<li>优点<blockquote>
<p>简洁<br>容易进行并行计算，添加一个parallel就行<br>有可能是未来编程的趋势<br>递归运行非常快，对其有专门的优化  </p>
</blockquote>
</li>
<li>缺点<blockquote>
<p>如果不使用并行计算，代码的效率并没有普通迭代的快（大多数情况）<br>没有办法进行return、continue、break、对异常进行处理等操作<br>不容易调试  </p>
</blockquote>
</li>
<li>相较于普通迭代的优点<blockquote>
<p>无存储<br>函数式风格，不会修改数据源<br>惰性执行<br>代码简洁<br>::Stream和iterator迭代的效率比较::<br>这里给出两篇博客，其中测试了Stream、parallel stream、iterator的执行效率<br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004171551">Java 8 Stream的性能到底如何？ - 某熊的全栈之路 - SegmentFault 思否</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Al_assad/article/details/82356606">JDK8 Stream 数据流效率分析_Al_assad的博客-CSDN博客_stream 效率</a><br>在这里直接给出相应的结论：</p>
</blockquote>
</li>
<li>数据量小的时候（size&lt;=1000）的时候iterator效率要比Stream高，不过都低于毫秒所以可以牺牲这一部分性能来追求Stream的可读性。</li>
<li>在大数据量（szie&gt;10000）时，Stream的处理效率要高一些，如果并行流使用得当效率还能更高。</li>
<li>并行流使用的时候受cpu的影响大，当没分配到多个cpu核心时，加上引用 forkJoinPool 的开销，运行效率可能还不如普通的 Stream。<br><code>如何用好Stream表达式</code></li>
</ul>
<ol>
<li><p><strong>注意装箱拆箱</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ;i&lt;<span class="number">10000</span> ;i++)&#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">List&lt;Integer&gt; collect = list.stream().map(x -&gt; ++x).collect(Collectors.toList());</span><br><span class="line"><span class="keyword">long</span> es = System.currentTimeMillis();</span><br><span class="line">System.out.println(es - s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">List&lt;Integer&gt; result = list.stream()</span><br><span class="line">        .mapToInt(x -&gt; ++x)</span><br><span class="line">        .boxed()</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"><span class="keyword">long</span> el = System.currentTimeMillis();</span><br><span class="line">System.out.println(el-l);</span><br></pre></td></tr></table></figure>
<p>我将10000个数值放入list中，以引用的形式来存储，在第一段代码中直接使用map进行操作自加1，最后又装箱成为List<Integer>，这里隐含了一个拆箱和装箱的步骤。<br>第二段代码中我将原始类型特化，将Stream<Integer> 特化为IntStream省去拆箱的时间，再使用boxed方法将流转化为Stream<Integer>最后使用收集为一个list，boxed函数的作用是将IntStream转化为Stream<Integer>，使流可以被收集为一个List<Integer>。<br>数据量10000级别的大小，上面两段代码在我的机器上执行速度分别为70和7毫秒左右，比值大约是10:1。</p>
</li>
<li><p><strong>不要因为强行使用Stream表达式，而抛弃了之前的迭代方法，这样可能更难理解，有效的结合起来使用更好</strong><br>首先是effective java中第7章中第45条谨慎使用Stream中它给出了一个例子<br>从词典文件中读取单词，并打印出单词数量大于用户指定的最低值的所有换位词，包含相同字母、字母顺序不同的两个词被称为换位词。比如”staple”和”petals”键都是”aelpst”,它们就是换位词。</p>
</li>
</ol>
<ul>
<li>不用Stream的代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File dictionary = <span class="keyword">new</span> File(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> minGroupSize = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; groups = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> (Scanner s = <span class="keyword">new</span> Scanner(dictionary)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (s.hasNext()) &#123;</span><br><span class="line">            String word = s.next();</span><br><span class="line">            groups.computeIfAbsent(alphabetize(word),(unused) -&gt; <span class="keyword">new</span> TreeSet&lt;&gt;()).add(word);</span><br><span class="line">				① computeIfAbsent是java8中map的新方法，当一个key不存在就设置一个值并返回值，如果存在就直接返回值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Set&lt;String&gt; group : groups.values())</span><br><span class="line">        <span class="keyword">if</span> (group.size() &gt;= minGroupSize)</span><br><span class="line">            System.out.println(group.size() + <span class="string">&quot;: &quot;</span> + group);②循环打印</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">alphabetize</span><span class="params">(String s)</span> </span>&#123;③分割字符串，将其组成的字母进行排序，这样就能找到两个词的共同键</span><br><span class="line">    <span class="keyword">char</span>[] a = s.toCharArray();</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
代码很长，但是仔细看能看懂，这时候就会想能不能用Stream进行优化</li>
<li>大量使用Stream的代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Path dictionary = Paths.get(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> minGroupSize = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (Stream&lt;String&gt; words = Files.lines(dictionary)) &#123;</span><br><span class="line">        words.collect(</span><br><span class="line">                groupingBy(word -&gt; word.chars().sorted()</span><br><span class="line">                        .collect(StringBuilder::<span class="keyword">new</span>,</span><br><span class="line">                                (sb, c) -&gt; sb.append((<span class="keyword">char</span>) c),</span><br><span class="line">                                StringBuilder::append).toString()))</span><br><span class="line">                .values().stream()</span><br><span class="line">                .filter(group -&gt; group.size() &gt;= minGroupSize)</span><br><span class="line">                .map(group -&gt; group.size() + <span class="string">&quot;: &quot;</span> + group)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
很多难懂，根本没有流失表达式的简洁和易读的特性</li>
<li>少量使用Stream的版本<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Path dictionary = Paths.get(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> minGroupSize = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (Stream&lt;String&gt; words = Files.lines(dictionary)) &#123;</span><br><span class="line">        words.collect(groupingBy(word -&gt; alphabetize(word)))</span><br><span class="line">                .values().stream()</span><br><span class="line">                .filter(group -&gt; group.size() &gt;= minGroupSize)</span><br><span class="line">                .forEach(g -&gt; System.out.println(g.size() + <span class="string">&quot;: &quot;</span> + g));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">alphabetize</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] a = s.toCharArray();</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
这样就舒服了很多，使用的alphabetize的方法是和第一个图中一样的方法，正因为这个方法让Stream变的比上面的代码易读很多<br>①按照word的字母组成进行分组,获取映射值的流<br>②进行过滤，按照最小分组长度筛选出比其长的分组<br>③打印</li>
</ul>
<ol start="3">
<li><p><strong>其次lambda表达式中的foreach不要随意使用</strong><br>下面来看effective java中第7章第46条中的一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</span><br><span class="line">Map&lt;String, Long&gt; freq = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">ArrayList&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">words.forEach(word -&gt; &#123;</span><br><span class="line">        freq.merge(word.toLowerCase(), <span class="number">1L</span>, Long::sum);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码是用来统计单词出现的次数，产生一个单词和频率的映射。看上去这么写也没问题，但是这段代码它对比普通迭代没有任何优势，它还是显式迭代，可读性反而变差了，而且比普通迭代更难维护。<br>我试了一下迭代版本和流式表达版本的效率差别，随机生成5000000条数据，执行代码，流式表达式Stream.foreach的执行时间是300以上，普通迭代是200以上不到300。<br>虽然这个测试不标准、正常情况下不会有这么大的数据量，当数据量不多的时候两者性能差别也不大，但是能看出来Stream.foreach和正常迭代相比在这种情况下没有执行速度上的优势。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</span><br><span class="line">Map&lt;String, Long&gt; freq = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">ArrayList&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">5000000</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> random = (<span class="keyword">int</span>)Math.random()*<span class="number">100</span>;</span><br><span class="line">    words.add(String.valueOf(random));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> st = System.currentTimeMillis();</span><br><span class="line">words.forEach(word -&gt; &#123;</span><br><span class="line">    freq.merge(word.toLowerCase(), <span class="number">1L</span>, Long::sum);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">long</span> et = System.currentTimeMillis();</span><br><span class="line">System.out.println(et-st);</span><br><span class="line"><span class="keyword">long</span> st1 = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">    freq.merge(word.toLowerCase(),<span class="number">1L</span>,Long::sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> et1 = System.currentTimeMillis();</span><br><span class="line">System.out.println(et1-st1);</span><br></pre></td></tr></table></figure>
<p>effective java中给出了另外一种流式写法来执行相应的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</span><br><span class="line">Map&lt;String, Long&gt; freq = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">ArrayList&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">freq = words</span><br><span class="line">        .collect(groupingBy(String::toLowerCase, counting()));</span><br></pre></td></tr></table></figure>
<p>这种写法是隐式迭代，正确的使用了lambda表达式。foreach操作应该只用于打印结果，而不是执行计算，有时候也可以将Stream计算的结果添加到之前已经存在的集合中。如果想要使用foreach循环进行操作，首先看是否可以转为Collection中的方法，Collection比foreach对流式表达更加友好，如果不行看看是否可以直接使用普通的迭代进行操作。</p>
</li>
<li><p><strong>谨慎使用Stream并行操作</strong><br>使用并行化的流式操作的时候一定要进行完善的测试，能确保其性能比串行要好，如果对Stream进行不恰当的并行操作，一定要确保代码正确，不会产生没有预料到的问题。</p>
</li>
</ol>
<ol start="5">
<li><strong>Collection中方法小技巧</strong><br>Collection中有很多方法，可以用其来简化很多之前的代码</li>
</ol>
<ul>
<li>toMap方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; collect = testList.stream().collect(toMap(Object::toString, t -&gt; t));</span><br></pre></td></tr></table></figure>
toMap中的两个参数第一个是映射的键，第二个是映射的值，但是如果多个Stream映射了同一个键就会报错。<br>解决方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; collect = testList.stream().collect(toMap(Object::toString, t -&gt; t,(old,newVal)-&gt; old+newVal));</span><br></pre></td></tr></table></figure>
使用三个参数的toMap方法，前两个参数与上面的toMap方法相同，第三个参数是如果产生键冲突如何处理，这里的处理方式是使用旧的值和新的值相加添加到映射值上。你也可以自定义，让其使用新的值进行更新或者乘除某个值等等。</li>
<li>groupingBy方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">freq = words.stream()</span><br><span class="line">        .collect(groupingBy(String::toLowerCase, counting()));</span><br></pre></td></tr></table></figure>
这样生成的Map的值是该元素出现的次数。<br>正确的使用Stream必须要了解收集器，最重要的收集器就是toList，toMap，toSet，groupingBy，joining等。<br>::总结::</li>
</ul>
<ol>
<li>普通迭代和流式表达式要结合起来使用，有更好的可读性，使用普通迭代也不会让你的性能下降。</li>
<li>写一个好的流操作很重要，其中涉及到装箱拆箱以及收集器的使用，如果使用不好性能会大大降低。</li>
<li>谨慎使用并行流。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/01/java8%E4%B8%AD%E7%9A%84%E6%B5%81%E5%BC%8F%E5%86%99%E6%B3%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/" data-id="ckejq82q40000nszxekwncvo6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-08-24" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/01/2020-08-24/" class="article-date">
  <time datetime="2020-08-31T16:00:00.000Z" itemprop="datePublished">2020-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/">阿里巴巴代码规范</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java阿里巴巴规范提示：方法【edit】需要在Transactional注解指定rollbackFor或者在方法中显示的rollback。"><a href="#Java阿里巴巴规范提示：方法【edit】需要在Transactional注解指定rollbackFor或者在方法中显示的rollback。" class="headerlink" title="Java阿里巴巴规范提示：方法【edit】需要在Transactional注解指定rollbackFor或者在方法中显示的rollback。"></a>Java阿里巴巴规范提示：方法【edit】需要在Transactional注解指定rollbackFor或者在方法中显示的rollback。</h1><p>先来看看异常的分类<br><img src="2020-08-24/_640.jpeg"><br>error是一定会回滚的。<br>这里Exception是异常，他又分为运行时异常RuntimeException和非运行时异常<br><img src="2020-08-24/__640.jpeg"></p>
<ol>
<li>可查的异常（checked exceptions）:Exception下除了RuntimeException外的异常</li>
<li>不可查的异常（unchecked exceptions）:RuntimeException及其子类和错误（Error）<br>如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。<br>如果不想终止，则必须捕获所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响下面对正常数据的处理。<br>非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。如IOException、SQLException等以及用户自定义的Exception异常。<br>对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。</li>
</ol>
<ul>
<li>@Transactional 的写法<br>开始主题@Transactional如果只这样写，<br>Spring框架的事务基础架构代码将默认地 只在抛出运行时和unchecked exceptions时才标识事务回滚。<br>也就是说，当抛出个RuntimeException 或其子类例的实例时。（Errors 也一样 - 默认地 - 标识事务回滚。）从事务方法中抛出的Checked exceptions将不被标识进行事务回滚。<br>1 让checked之外的异常也回滚：</li>
</ul>
<p>在整个方法前加上 @Transactional(rollbackFor=Exception.class)</p>
<p>2 让unchecked之外的异常不回滚：</p>
<p>@Transactional(notRollbackFor=RunTimeException.class)</p>
<p>3 不需要事务管理的(只查询的)方法：</p>
<p>@Transactional(propagation=Propagation.NOT_SUPPORTED)</p>
<p>注意：如果异常被try｛｝catch｛｝了，事务就不回滚了，如果想让事务回滚必须再往外抛try｛｝catch｛throw Exception｝。</p>
<h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>Spring团队的建议是你在具体的类（或类的方法）上使用@Transactional 注解，而不要使用在类所要实现的任何接口上。</p>
<p>你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因此，请接受Spring团队的建议并且在具体的类上使用 @Transactional 注解。</p>
<p>@Transactional 注解标识的方法，处理过程尽量的简单。尤其是带锁的事务方法，能不放在事务里面的最好不要放在事务里面。可以将常规的数据库查询操作放在事务前面进行，而事务内进行增、删、改、加锁查询等操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/01/2020-08-24/" data-id="ckejvvygf0000mjzxa0t05ril" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-FeginClient参数问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/01/FeginClient%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-08-31T16:00:00.000Z" itemprop="datePublished">2020-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringCloud/">SpringCloud</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="FeginClient参数问题"><a href="#FeginClient参数问题" class="headerlink" title="FeginClient参数问题"></a>FeginClient参数问题</h1><h2 id="使用Get方式调用服务提供者"><a href="#使用Get方式调用服务提供者" class="headerlink" title="使用Get方式调用服务提供者"></a>使用Get方式调用服务提供者</h2><ol>
<li>服务消费者，需要在所有参数前加上@RequestParam注解</li>
<li>服务消费者，指明是Get方式，如果不指明那么在满足条件1 的情况下默认使用get方式<br>1和2都满足才使用Get方式<h2 id="使用Post方式调用服务提供者"><a href="#使用Post方式调用服务提供者" class="headerlink" title="使用Post方式调用服务提供者"></a>使用Post方式调用服务提供者</h2></li>
<li>在所有参数前面加上@RequestParam注解，并且指明使用的Post方式</li>
<li>在参数前面加上@RequestBody注解（有且只有一个@ RequestBody）或者什么也没有（有多个参数其余参数前面都要加上@RequestParam）<br>1和2满足一个就使用Post方式<h2 id="三种情况（无参、单参、多参）"><a href="#三种情况（无参、单参、多参）" class="headerlink" title="三种情况（无参、单参、多参）"></a>三种情况（无参、单参、多参）</h2><h3 id="无参Get"><a href="#无参Get" class="headerlink" title="无参Get"></a>无参Get</h3>如果发送无参的Get请求，可以不指定method，默认就是Get请求<h3 id="无参Post"><a href="#无参Post" class="headerlink" title="无参Post"></a>无参Post</h3>指定method是Post方式，否则就是Get请求<h3 id="单参Get"><a href="#单参Get" class="headerlink" title="单参Get"></a>单参Get</h3>指定该参数是@RequestParam修饰，这时候method默认是Get，也可以自己指定Get方式<h3 id="单参Post"><a href="#单参Post" class="headerlink" title="单参Post"></a>单参Post</h3>该参数前面加@RequestParam修饰，并且使用Post方式<br>或者<br>使用@RequestBody修饰该参数，或者没使用@RequestParam和@RequestBody修饰该参数，再这个使用不论指定Post还是Get都会使用Post进行请求</li>
</ol>
<p><strong>注意：</strong><br>在使用fegin消费服务的时候，如果参数前面什么也没写，默认是@RequestBody来修饰的<br>@RequestBody修饰的参数需要以Post方式来传递</p>
<blockquote>
<p>在服务提供者的Controller中：<br>1.如果要接收@RequestBody指明的参数，那么对应方法的对应参数前一定要有@RequestBody；(如果没有的话，收到的参数值就为null;如果写成@RequestParam的话，那么feign调用会失败)<br>2.如果接收@ RequestParam指明的参数，那么可以写@ RequestParam也可以不写，如果参数名称一致不用，不一致需要写  </p>
</blockquote>
<h3 id="多参Get"><a href="#多参Get" class="headerlink" title="多参Get"></a>多参Get</h3><p>需要在所有参数前面添加@ RequestParam注解，这时候可以加Get也可以不加Get</p>
<h3 id="多参Post"><a href="#多参Post" class="headerlink" title="多参Post"></a>多参Post</h3><p>服务消费者中，最多只能有一个参数是@RequestBody指明的，其余的参数必须使用@RequestParam指明<br>也可以在第一个参数前面什么也不写（默认使用@RequestBody修饰）其余的参数都需要加@RequestParam<br>如果所有参数都是以@RequestParam修饰，并且使用的是Post方式，那么也是以Post方式来请求</p>
<blockquote>
<p>在服务提供者的Controller中：<br>1.如果服务消费者传过来参数时，全都用的是@RequestParam的话，那么服务提供者的Controller中对应参数前可以写@RequestParam,也可以不写(当两边参数名字一致时，可以省略不写)  </p>
<ol start="2">
<li>如果服务消费者传过来参数时，有@RequestBody的话，那么服务提供者的Controller中对应参数前必须要写@RequestBody(如果是多参数的话，其余参数前视情况可以写@RequestParam,也可以不写)  </li>
</ol>
</blockquote>
<h2 id="RequestBody和-RequestParam的区别"><a href="#RequestBody和-RequestParam的区别" class="headerlink" title="@RequestBody和@RequestParam的区别"></a>@RequestBody和@RequestParam的区别</h2><p>@RequestParam用来处理Content-Type: 为 application_x-www-form-urlencoded编码的内容，在Http中如果不指定Content-Type则默认使用application_x-www-form-urlencoded类型<br>@ RequestBody，处理HttpEntity传递过来的数据，用来处理非Content-Type: application/x-www-form-urlencoded编码格式的数据<br>    * Get请求没有HttpEntity所以不用@ RequestBody<br>    * POST请求中，通过HttpEntity传递的参数，必须要在请求头中声明数据的类型Content-Type，SpringMVC通过使用HandlerAdapter 配置的HttpMessageConverters来解析HttpEntity中的数据，然后绑定到相应的bean上<br>总结：Get不能使用表单，只能在url中传参，传参方式只有这一种。 Post可以使用表单，也可以在url中传参。使用表单时有几种数据类型（表现为数据的存储位置不同）：1、 x-www-form-urlencoded 参数存储在query中 用@RequestParam接收。2、formdata 参数存储在body中，用@RequestBody接收，文件类型用@RequestPart接收。3、raw(josn,xml) 参数存储在body中 用@RequetBody接收。总结一下： 凡是放在body中的都可以用@RequestBody接收，文件类型的数据可以用@RequestPart接收。 凡是放在query中的都可以用@RequestParam接收，包括Get方式提交和Post(x-www-form-urlencoded)方式提交的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/01/FeginClient%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/" data-id="ckejvvygk0001mjzxf0xf0acn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java8中Map.merge、compute、computeIfAbsent、computeIfPre" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/01/Java8%E4%B8%ADMap.merge%E3%80%81compute%E3%80%81computeIfAbsent%E3%80%81computeIfPre/" class="article-date">
  <time datetime="2020-08-31T16:00:00.000Z" itemprop="datePublished">2020-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java8/">Java8</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java8中Map-merge、compute、computeIfAbsent、computeIfPresent方法"><a href="#Java8中Map-merge、compute、computeIfAbsent、computeIfPresent方法" class="headerlink" title="Java8中Map.merge、compute、computeIfAbsent、computeIfPresent方法"></a>Java8中Map.merge、compute、computeIfAbsent、computeIfPresent方法</h1><ul>
<li><strong>merge</strong><br>java8中Map类添加了merge、compute、computeIfAbsent、computeIfPresent的缺省方法，下面给出的源码都是Map类中的，Map的实现类在实现这些方法上会有不同<br><code>方法解释</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">* If the specified key is not already associated with a value or is</span><br><span class="line">* associated with <span class="keyword">null</span>, associates it with the given non-<span class="keyword">null</span> value.</span><br><span class="line">* Otherwise, replaces the associated value with the results of the given</span><br><span class="line">* remapping function, or removes <span class="keyword">if</span> the result is &#123;<span class="meta">@code</span> <span class="keyword">null</span>&#125;. This</span><br><span class="line">* method may be of use when combining multiple mapped values <span class="keyword">for</span> a key.</span><br><span class="line"><span class="comment">// 如果一个指定的key其关联的值是空或者该key不存在，将会给他一个非空的值，除此之外，用所给的BiFunction方法的结果来替换关联的值，如果方法计算结果是null就删除该key</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">merge</span><span class="params">(K key, V value,</span></span></span><br><span class="line"><span class="function"><span class="params">        BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(remappingFunction);①</span><br><span class="line">    Objects.requireNonNull(value);②</span><br><span class="line">    V oldValue = get(key);③</span><br><span class="line">    V newValue = (oldValue == <span class="keyword">null</span>) ? value :</span><br><span class="line">               remappingFunction.apply(oldValue, value);④</span><br><span class="line">    <span class="keyword">if</span>(newValue == <span class="keyword">null</span>) &#123;⑤</span><br><span class="line">        remove(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        put(key, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
①、②判断BiFunction以及默认值是否为空<br>③获取指定key的值赋予oldValue<br>④判断oldValue是否为空，如果是空newValue = 默认值，不为空newValue = BiFunction.apply(oldValue,value)<br>⑤判断newValue是否为空，为空就直接删除key，不为空更新key-value<br><code>如何使用</code><br>arrayList.forEach(a -&gt; map.merge(a,1,(prev,one)-&gt;prev+one));<br>用处：循环遍历arrayList，使用map存储arrayList中值出现的次数,(prev,one)-&gt;prev+one 该函数的作用是，当有指定的key时用旧值加1作为新值更新key</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户账号操作类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal bigDecimal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Operation</span><span class="params">(String name, BigDecimal bigDecimal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.bigDecimal = bigDecimal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getBigDecimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bigDecimal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBigDecimal</span><span class="params">(BigDecimal bigDecimal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bigDecimal = bigDecimal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapMergeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Operation&gt; operations = Arrays.asList(<span class="keyword">new</span> Operation(<span class="string">&quot;123&quot;</span>,<span class="keyword">new</span> BigDecimal(<span class="string">&quot;10&quot;</span>)),<span class="keyword">new</span> Operation(<span class="string">&quot;123&quot;</span>,<span class="keyword">new</span> BigDecimal(<span class="string">&quot;-20&quot;</span>)));</span><br><span class="line">        HashMap&lt;String, BigDecimal&gt; stringBigDecimalHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        operations.forEach(operation -&gt; stringBigDecimalHashMap.merge(operation.getName(),operation.getBigDecimal(),BigDecimal::add));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户账号操作类是用来记录用户们每次操作的用户名和操作账户数值<br>最后stringBigDecimalHashMap用来保存每个用户以及其账户最终数值，用BigDecimal::add方法引用来替换之前的lamdba表达式</p>
<ul>
<li><p><strong>compute</strong><br><code>方法解释</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">* Attempts to compute a mapping <span class="keyword">for</span> the specified key and its current</span><br><span class="line">* <span class="function">mapped <span class="title">value</span> <span class="params">(or &#123;<span class="meta">@code</span> <span class="keyword">null</span>&#125; <span class="keyword">if</span> there is no current mapping)</span>.</span></span><br><span class="line"><span class="function"><span class="comment">// 试着去指定一个值给给定的key</span></span></span><br><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">compute</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">        BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(remappingFunction);①判断空</span><br><span class="line">    V oldValue = get(key);</span><br><span class="line"></span><br><span class="line">    V newValue = remappingFunction.apply(key, oldValue);<span class="comment">// 注意这里的apply中的第一个参数是对应的key，第二个参数是取出的默认值</span></span><br><span class="line">    <span class="keyword">if</span> (newValue == <span class="keyword">null</span>) &#123;②如果计算出的新值是<span class="keyword">null</span>，就保证将key删除</span><br><span class="line">        <span class="comment">// delete mapping</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue != <span class="keyword">null</span> || containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// something to remove</span></span><br><span class="line">            remove(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// nothing to do. Leave things as they were.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;③非<span class="keyword">null</span>就设置该key为newValue，不管其是否存在</span><br><span class="line">        <span class="comment">// add or replace old mapping</span></span><br><span class="line">        put(key, newValue);</span><br><span class="line">        <span class="keyword">return</span> newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>如何使用</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.eurekaserverdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapMergeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; stringIntegerHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        stringIntegerHashMap.put(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        stringIntegerHashMap.put(<span class="string">&quot;2&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        stringIntegerHashMap.put(<span class="string">&quot;3&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        stringIntegerHashMap.compute(<span class="string">&quot;1&quot;</span>, (k,v)-&gt;v+<span class="number">1</span>);①返回取出的旧值加一再设置给key</span><br><span class="line">        stringIntegerHashMap.compute(<span class="string">&quot;4&quot;</span>,(k,v)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(k)) <span class="keyword">return</span> v+<span class="number">1</span>;②判断是否包含当前key，如果包含就返回oldValue+<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;③如果没有key就设置一个默认值</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(stringIntegerHashMap.get(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">        System.out.println(stringIntegerHashMap.get(<span class="string">&quot;4&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>compute方法可以做到和merge方法类似的事情，给map中不存在的key设置一个默认值，存在的key使用BiFunction来进行操作，但是compute方法没有merge方法在这方面好扩展因为它没办法指定BiFunction中的全部参数<br>compute优点是初始化数据的时候可以处理快一些，不论是否存在都给定一个初始值</p>
</li>
<li><p><strong>computeIfAbsent</strong><br><code>方法解释</code><br>见名知意，该方法compute方法只用于key不存在的时候，如果key存在直接返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">computeIfAbsent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">        Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;①注意这里传入的是一个Function，只有一个参数值，这点与compute不同</span><br><span class="line">    Objects.requireNonNull(mappingFunction);</span><br><span class="line">    V v;</span><br><span class="line">    <span class="keyword">if</span> ((v = get(key)) == <span class="keyword">null</span>) &#123;②判断该key不存在才执行</span><br><span class="line">        V newValue;</span><br><span class="line">        <span class="keyword">if</span> ((newValue = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;③使用传入的key值作为参数来执行传入的lambda</span><br><span class="line">            put(key, newValue);</span><br><span class="line">            <span class="keyword">return</span> newValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>computeIfPresent</strong><br><code>方法解释</code><br>该方法compute方法只用于key存在的时候，如果key不存在返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">computeIfPresent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">        BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;①传入两个参数</span><br><span class="line">    Objects.requireNonNull(remappingFunction);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">if</span> ((oldValue = get(key)) != <span class="keyword">null</span>) &#123;②如果存在key就设置newValue</span><br><span class="line">        V newValue = remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (newValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            put(key, newValue);</span><br><span class="line">            <span class="keyword">return</span> newValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            remove(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/01/Java8%E4%B8%ADMap.merge%E3%80%81compute%E3%80%81computeIfAbsent%E3%80%81computeIfPre/" data-id="ckejvvygm0002mjzx6muz0qqe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java8新特性学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/01/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-08-31T16:00:00.000Z" itemprop="datePublished">2020-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java8/">java8</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java8新特性学习"><a href="#Java8新特性学习" class="headerlink" title="Java8新特性学习"></a>Java8新特性学习</h1><h2 id="1、lambda表达式"><a href="#1、lambda表达式" class="headerlink" title="1、lambda表达式"></a>1、lambda表达式</h2><p>Lambda允许将函数作为参数传递到方法中，可以使代码变得更加紧凑</p>
<p>使用lambda可以对某些接口进行简单的实现，不过不是所有接口都可以使用lambda来实现</p>
<p>Lambda规定接口中只能有一个需要被实现的方法（不是说接口中只能有一个方法）</p>
<blockquote>
<p>Java8中被default修饰的方法会有默认实现，不是必须被实现的方法，这样不影响lambda的使用<br>语法形式是：()-&gt; {} ,()是参数列表，{}是描述方法体</p>
</blockquote>
<p>简单的lambda实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">            <span class="comment">// 不用括号</span></span><br><span class="line">            GreetingService greetService1 = message -&gt;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">            GreetingService greetingService = <span class="keyword">new</span> GreetingService() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            greetService1.sayMessage(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">            greetingService.sayMessage(<span class="string">&quot;Baidu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把上面的lambda看成下面的匿名内部类的实现方法</p>
<p>GreetingService greetService1 = message -&gt;<br>System.out.println(“Hello “ + message);</p>
<p>意思是实现GreetingService的接口方法，其中message是参数，方法体是 System.out.println(“Hello “ + message);</p>
<p>故可以通过greetService1.sayMessage(“Runoob”);直接调用</p>
<ul>
<li>可以直接省略参数类型，编译器自动识别参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> a,<span class="keyword">int</span> b) --&gt; (a,b)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果只有一个参数可以不加(),多个需要加</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> a) --&gt; a</span><br></pre></td></tr></table></figure>

<ul>
<li>方法体中只有一个语句，可以省略{}</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;System.out.println(<span class="string">&quot;Hello &quot;</span> + message);&#125; --&gt; System.out.println(<span class="string">&quot;Hello &quot;</span> + message); </span><br></pre></td></tr></table></figure>

<ul>
<li>方法体中只有一个表达式返回值，编译器会自动返回值，大括号需要指定明表达式返回了一个数值</li>
</ul>
<p>lambda表达式只能访问标记了final的外部变量，或者是局部变量但是该变量后面必须不能被修改（具有隐式的final属性）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String FINAL_1 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String FINAL_2 = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">            <span class="comment">// 不用括号</span></span><br><span class="line">        String final_3 = <span class="string">&quot;3&quot;</span>;</span><br><span class="line">            GreetingService greetService1 = message -&gt; System.out.println(<span class="string">&quot;Hello &quot;</span> + message + FINAL_1 + FINAL_2 + final_3);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//final_3 = &quot;4&quot;;</span></span><br><span class="line">            GreetingService greetingService = <span class="keyword">new</span> GreetingService() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            greetService1.sayMessage(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">            greetingService.sayMessage(<span class="string">&quot;Baidu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上面的代码把final_3 = “4” 取消注释则会报错</p>
<h2 id="2、方法引用"><a href="#2、方法引用" class="headerlink" title="2、方法引用"></a>2、方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        GreetingService greetingService2 = Java8Tester::setMessage;</span><br><span class="line"></span><br><span class="line">        Java8Tester java8Tester = <span class="keyword">new</span> Java8Tester();</span><br><span class="line">        GreetingService greetingService3 = java8Tester::setMessage_2;</span><br><span class="line">        </span><br><span class="line">        greetingService2.sayMessage(<span class="string">&quot;kuake&quot;</span>);</span><br><span class="line">        greetingService3.sayMessage(<span class="string">&quot;360&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str + <span class="string">&quot;这是静态方法实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage_2</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(str + <span class="string">&quot;非静态方法实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有时候想要调用其他方法来快速实现接口方法时，就可以通过方法引用的形式：</p>
<p>如果是静态方法</p>
<ul>
<li>类名::方法名</li>
</ul>
<p>如果是普通方法</p>
<ul>
<li>对象名::方法名</li>
</ul>
<p>上面的代码就是使用setMessage和setMessag_2来实现了sayMessage接口方法</p>
<p>使用引用方法来遍历集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Collections.addAll(list, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//方法引用来输出集合</span></span><br><span class="line">list.forEach(System.out::println);</span><br><span class="line"><span class="comment">//使用lambda来遍历输出集合</span></span><br><span class="line">list.forEach(element -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (element % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">          System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="3、流式操作"><a href="#3、流式操作" class="headerlink" title="3、流式操作"></a>3、流式操作</h2><p>stream是一个来自于数据源的元素队列，它支持聚合操作</p>
<p>就好像是一个迭代器，单向、不可往复，数据只能遍历一次，遍历后就用尽了</p>
<p>数据源可以是集合、IO对象、数组等</p>
<p>聚合操作：</p>
<ul>
<li>map</li>
</ul>
<p>map是映射每个元素对应的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">List&lt;Integer&gt; collect = list.stream().map(i -&gt; i * <span class="number">2</span>).collect(Collectors.toList());</span><br><span class="line">collect.forEach(System.out::print);</span><br></pre></td></tr></table></figure>

<p>这里的map(i -&gt; i*2)就是把list中所有元素乘2后再通过collect来组成一个集合</p>
<ul>
<li>filter</li>
</ul>
<p>filter通过设置条件过滤出元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt;    !string.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>过滤出strings为空的元素</p>
<ul>
<li>limit</li>
</ul>
<p>limit获取指定数量的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">list.stream().limit(<span class="number">3</span>).forEach(System.out::print);</span><br></pre></td></tr></table></figure>

<p>获取前三个数据，但是该方法无法指定两个参数，就像sql中limit(1,3)取出两个数据</p>
<ul>
<li>sorted</li>
</ul>
<p>用于排序操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">list.stream().sorted().forEach(System.out::print);</span><br></pre></td></tr></table></figure>

<p>将1,2,3,7,4,3排序输出</p>
<p>Collectors</p>
<p>实现归约操作，将流转化成集合，Collectors可用于返回列表和字符串</p>
<p>在上面的聚合操作后均可以将其转化为对应的列表如map操作所示</p>
<p>Stream的优点：</p>
<ul>
<li>无储存，stream不是一种数据结构，而是某个数据源的视图，数据源可以使集合、数组、IO流</li>
<li>对stream的任何操作都不会影响到背后的数据源</li>
<li>惰性执行，只有等到用户真的需要结果才运行</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/01/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/" data-id="ckejvvygo0003mjzx2fyp4tfm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux常用命令学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/01/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-08-31T16:00:00.000Z" itemprop="datePublished">2020-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%91%BD%E4%BB%A4%E8%A1%8C/">命令行</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Linux常用命令学习"><a href="#Linux常用命令学习" class="headerlink" title="Linux常用命令学习"></a>Linux常用命令学习</h1><p>#Java/基础学习</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>1、cd</p>
<p>格式：cd + &lt;路径&gt;</p>
<ul>
<li><p>cd Documents 表示切换到当前目录下</p>
</li>
<li><p>cd _Documents_index 切换到Documents下的index文件夹下</p>
</li>
<li><p>cd ..回到上一级</p>
</li>
<li><p>cd / 切换到根目录</p>
</li>
<li><p>cd ~ 进入home目录</p>
</li>
<li><p>cd - 进入上一次工作路径</p>
</li>
</ul>
<p>2、ls</p>
<p>格式：ls + &lt;参数&gt; + &lt;路径&gt;</p>
<ul>
<li><p>ls / 显示根目录下所有文件</p>
</li>
<li><p>ls 显示当前路径下的所有文件名</p>
</li>
<li><p>ls -l 显示当前路径下所有文件及其详细信息</p>
</li>
<li><p>ls -a 列出所有目录文件，包括以 . 开头的隐藏文件</p>
</li>
<li><p>ls -A 列出除了 . 和.. 的其他文件</p>
</li>
</ul>
<p>3、cat</p>
<p>格式：cat + &lt;参数&gt; + &lt;文件&gt;</p>
<ul>
<li>cat index.txt 读取当前路径下的index.txt内容并显示</li>
<li>cat &gt; filename 从键盘创建一个文件</li>
<li>cat file1 file2 &gt; file 几个文件合并为一个文件</li>
</ul>
<p>4、pwd</p>
<p>用于查看当前的工作路径</p>
<ul>
<li>pwd 查看当前路径</li>
</ul>
<p>5、mkdir</p>
<p>格式：mkdir + &lt;文件夹&gt; 用于创建文件夹</p>
<ul>
<li>mkdir  _Documents_index  在Documents里创建index文件夹</li>
<li>mkdir -p a_b_c   -p用于创建多级文件夹，该命令表示在当前路径下，创建文件夹a，a文件夹包括b文件夹，b里包括c文件夹</li>
</ul>
<p>6、rm 删除目录或文件，不使用-r，可以删除目录</p>
<p>格式：rm + &lt;参数&gt; + &lt;文件&gt;，用于删除文件或目录，删除文件要保证拥有修改权限</p>
<ul>
<li><p>rm -f index.txt 删除index.txt文件</p>
</li>
<li><p>rm -r index/index.txt  删除当前路径下的index目录或者index.txt 文件</p>
</li>
<li><p>rm index.txt 删除index.txt文件</p>
</li>
</ul>
<p>7、cp</p>
<p>格式：cp + &lt;文件&gt; + &lt;目标文件&gt; 或者cp -r &lt;文件夹&gt; &lt;目标文件夹&gt;</p>
<ul>
<li>cp index.txt file 将index.txt复制到file目录下</li>
<li>cp -r 复制目录及目录内所有项目</li>
</ul>
<p>8、touch 命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文</p>
<p>使用方法：touch + &lt;文件&gt;</p>
<h2 id="vi-vim命令"><a href="#vi-vim命令" class="headerlink" title="vi/vim命令"></a>vi/vim命令</h2><p>vim是一个从vi发展出了的文本编辑器</p>
<p>vi/vim分为3中模式：</p>
<ul>
<li>命令模式</li>
<li>输入模式</li>
<li>底线命令模式</li>
</ul>
<p>命令模式：</p>
<p>当我们刚启动vi/vim，就会进入命令模式，现在我们在键盘上敲不会被认为是向文件中输入，而是被当做命令</p>
<p>1、i 切换到输入模式</p>
<p>2、：切换到底线命令模式</p>
<p>输入模式：</p>
<p>可以在其中正常键入数据，按ESC退回到命令模式</p>
<p>底线命令模式：</p>
<p>1、q退出程序</p>
<p>2、w保存文件</p>
<p>3、wq 存储后离开，若为:wq! 则为强制存储后离开</p>
<p>ESC也可以随时退出底线命令模式</p>
<p>关系转换图：</p>
<p>image-20200424192414458</p>
<p>下面给出在vim一般模式中常用的命令：</p>
<ul>
<li><p>0 移动到这一行最前面的字符处</p>
</li>
<li><p>$ 移动到这一行最后面字符处</p>
</li>
<li><p>G 移动到这个文件最后一行</p>
</li>
<li><p>gg 移动到这个文件第一行</p>
</li>
<li><p>n n是数字，光标向下移动n行</p>
</li>
</ul>
<p>Git 放弃本地所有的修改：</p>
<p>git checkout .</p>
<p>git stash stash pophuif</p>
<p>git clean -n</p>
<p>git clean -f</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/01/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/" data-id="ckejvvygp0004mjzxdyujg6bj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Redis中的特殊类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/01/Redis%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time datetime="2020-08-31T16:00:00.000Z" itemprop="datePublished">2020-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis%E5%AD%A6%E4%B9%A0/">Redis学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Redis中的特殊类型"><a href="#Redis中的特殊类型" class="headerlink" title="Redis中的特殊类型"></a>Redis中的特殊类型</h1><h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><p>是用来存储地理位置的一个数据结构<br>Geo是在Redis3.2版本中推出的，这个功能可以推算地理位置信息，两地的距离，方圆几里的人<br>下面涉及到经度纬度的存储，可以用<a target="_blank" rel="noopener" href="http://www.jsons.cn/lngcodeinfo/0706D99C19A781A3/">查询城市经度纬度</a>来查询测试数据</p>
<ul>
<li>命令使用 <blockquote>
<p>geoadd 添加key以及对应的经度 纬度 名称  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 经度在前纬度在后</span></span><br><span class="line"><span class="comment"># 有效的经度从-180度到180度。</span></span><br><span class="line"><span class="comment">#	有效的纬度从-85.05112878度到85.05112878度。</span></span><br><span class="line"><span class="comment"># 当坐标位置超出上述指定范围时，该命令将会返回一个错误。</span></span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116 39 beijing   	<span class="comment">#向china:city key 中添加北京的经度纬度</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121 31 shanghai</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqi 114.05 22.52 shengzhen</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>getpos 显示key的经度纬度  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos china:city beijing    <span class="comment">#显示北京的经度纬度，若没有则显示空</span></span><br><span class="line">1) 1) <span class="string">&quot;116.00000113248825073&quot;</span></span><br><span class="line">   2) <span class="string">&quot;38.99999918434559731&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geopos china:city guangzhou</span><br><span class="line">1) (nil)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>geodist 显示两地的距离  （将地球作为一个完美球体进行计算，误差在0.5%以内）<br>如果两个位置之间的其中一个不存在， 那么命令返回空值。<br>指定单位的参数 unit 必须是以下单位的其中一个。<br><strong>m</strong> 表示单位为米。<br><strong>km</strong> 表示单位为千米。<br><strong>mi</strong> 表示单位为英里。<br><strong>ft</strong> 表示单位为英尺。<br>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai km   <span class="comment">#以千米为单位显示北京到上海的距离</span></span><br><span class="line"><span class="string">&quot;999.2077&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>georadius 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素<br>范围可以是  m km mi ft<br>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。<br>WITHCOORD: 将位置元素的经度和维度也一并返回。  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km   <span class="comment">#找经度110纬度30方圆1000km以内的元素</span></span><br><span class="line">1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shengzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withcoord   <span class="comment">#显示元素的经度纬度</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;shengzhen&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;114.04999762773513794&quot;</span></span><br><span class="line">      2) <span class="string">&quot;22.5200000879503861&quot;</span></span><br><span class="line">4) 1) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;120.1600000262260437&quot;</span></span><br><span class="line">      2) <span class="string">&quot;30.2400003229490224&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withdist   <span class="comment">#显示到110 30 的具体距离</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">   2) <span class="string">&quot;341.9374&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) <span class="string">&quot;483.8340&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km count 1		<span class="comment">#筛选指定的结果</span></span><br><span class="line">1) <span class="string">&quot;chongqi&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>georadiusbymember 找出位于指定元素周围的其他元素  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km </span><br><span class="line">1) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span> 127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city shanghai 400 km </span><br><span class="line">1) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">2) <span class="string">&quot;shanghai&quot;</span> </span><br></pre></td></tr></table></figure>
<blockquote>
<p>geohash  返回一个或多个位置元素的geohash表示<br>该命令返回一个11字符的字符串  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将经度纬度转换为一维字符串，如果两个字符串接近，那么距离越近，可以根据这个字符串去查找到对应位置</span></span><br><span class="line">127.0.0.1:6379&gt; geohash china:city beijing chongqi		</span><br><span class="line">1) <span class="string">&quot;wwfmzesx7y0&quot;</span></span><br><span class="line">2) <span class="string">&quot;wm5xzrybty0&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><blockquote>
<p>统计基数  </p>
</blockquote>
<ul>
<li>什么是基数<br>有集合A{1、2、3、4、5} 和集合B{2、2、3、3、4、5、6}<br>基数用大白话讲就是一个集合中不重复的元素<br>所以A的基数就是5，B的基数也是5（除去重复的2和3）<br>在Redis统计基数中是有误差的</li>
<li>Redis中的Hyperloglog<br>优点：占用内存是固定的，2^64次方个不同元素的基数，只需要12KB的内存<br>可以用来做什么？<br>存储网页的访问数（一个人访问一个网站多次，只算一次访问）<br>传统的方式中是使用set来存储，由于set是无序无重复的，多次插入一个用户ID也存储的是一个值，但是当数据量很大的时候就会很麻烦，我们要做的是计数而不是存储ID<br>那么就可以使用Hyperloglog，虽然有误差但是在网页的访问数中也可以忽略这些误差</li>
<li>如何使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFadd mykey a b c d e    <span class="comment">#创建第一组元素mykey</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey   <span class="comment">#统计mykey中的基数数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; PFADD mykey b c d e f   <span class="comment">#继续向mykey中添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey     <span class="comment">#统计mykey中的基数数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; PFADD mykey1 b c d e f g   <span class="comment">#创建第二组元素mykey1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey1      <span class="comment">#统计mykey1中的基数数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE mykey2 mykey mykey1  <span class="comment">#合并两组元素</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey2			<span class="comment">#统计合并后的基数数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br></pre></td></tr></table></figure>
<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><blockquote>
<p>位存储<br>统计一个用户活跃、不活跃 登录、没登录 打卡、没打卡<br>位存储存储的就是01值，任何两个状态的事物都可以用01来存储</p>
</blockquote>
</li>
<li>如何使用<br>这里使用其来存储一个人一周打卡的情况<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 0 0   <span class="comment">#key是sign  第一个0代表周一  第二个0代表周二</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; GETBIT sign 1	<span class="comment">#获取signkey星期一的签到状态</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; bitcount sign	<span class="comment">#获取sign本周的签到天数</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/01/Redis%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B/" data-id="ckejvvygq0005mjzx88x9a4as" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Redis事务与基本实现代码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/01/Redis%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81/" class="article-date">
  <time datetime="2020-08-31T16:00:00.000Z" itemprop="datePublished">2020-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis%E5%AD%A6%E4%B9%A0/">Redis学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Redis事务与基本实现代码"><a href="#Redis事务与基本实现代码" class="headerlink" title="Redis事务与基本实现代码"></a>Redis事务与基本实现代码</h1><p>redis事务的本质是：一组命令的集合，一个事务中所有命令都会被按顺序放在队列中，在发起执行命令的时候队列中的命令会被一一执行</p>
<ul>
<li>Redis事务没有隔离级别的概念</li>
<li>Redis单条命令保证原子性，但是事务不保证原子性<br>redis事务：</li>
</ul>
<ol>
<li>开启事务（multi）</li>
<li>命令入队（…..）</li>
<li>执行事务（exec）</li>
</ol>
<hr>
<blockquote>
<p>正常执行事务  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span>		<span class="comment">#执行事务</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>放弃事务的执行  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; discard</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命令错误  所有的命令都不会被执行  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; sett k1 v2</span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `sett`, with args beginning with: `k1`, `v2`,</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行时异常，队列中的命令存在语法性的错误，执行的时候其他命令是可以执行的，错误命令抛出异常  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 <span class="string">&quot;v1&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr k1  		<span class="comment">#有语法错误，其作用是为k1上的值加1，如果k1的值不是数字就会报错</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">&quot;v2&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>监控命令<br>watch(乐观锁机制)  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money		<span class="comment">#监控money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby money 10  <span class="comment">#让money减10</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span>		<span class="comment">#在执行前开启另外一个客户端修改money的值，就会执行失败</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get money</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>如果修改失败，我们将其解锁再重新监控就好</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; Unwatch		<span class="comment">#解锁</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money	<span class="comment">#重新监控money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi		</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby money 10	<span class="comment">#让money减10</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span>			<span class="comment">#执行</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 90</span><br></pre></td></tr></table></figure>
<h2 id="代码中使用Redis"><a href="#代码中使用Redis" class="headerlink" title="代码中使用Redis"></a>代码中使用Redis</h2><p>Jedis是Redis官方推荐的Java连接Redis工具<br>导入包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Jedis所有函数都与Redis中的命令行相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis测试</span></span><br><span class="line"><span class="comment"> * 测试redis的事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        jedis.flushDB();</span><br><span class="line"></span><br><span class="line">        Transaction multi = jedis.multi();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">&quot;user1&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            multi.set(<span class="string">&quot;user2&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;<span class="comment">// 报错放弃事务</span></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            multi.discard();<span class="comment">// 放弃事务</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArithmeticException: &#x2F; by zero</span><br><span class="line">	at RedisDemo.main(RedisDemo.java:17)</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/01/Redis%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81/" data-id="ckejvvygr0006mjzx4vbvcmpv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SpringCloud主要包括什么" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/01/SpringCloud%E4%B8%BB%E8%A6%81%E5%8C%85%E6%8B%AC%E4%BB%80%E4%B9%88/" class="article-date">
  <time datetime="2020-08-31T16:00:00.000Z" itemprop="datePublished">2020-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringCloud/">SpringCloud</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SpringCloud主要包括什么"><a href="#SpringCloud主要包括什么" class="headerlink" title="SpringCloud主要包括什么"></a>SpringCloud主要包括什么</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>Eureka是Netfix中的一个提供服务注册和发现的产品。<br>用大白话讲，Eureka 就是一个服务中心，将所有的可以提供的服务都注册到它这里来管理，其它各调用者需要的时候去注册中心获取，然后再进行调用，避免了服务之间的直接调用，方便后续的水平扩展、故障转移等。<br>当然服务中心这么重要的组件一但挂掉将会影响全部服务，因此需要搭建 Eureka 集群来保持高可用性，生产中建议最少两台。随着系统的流量不断增加，需要根据情况来扩展某个服务，Eureka 内部已经提供均衡负载的功能，只需要增加相应的服务端实例既可。那么在系统的运行期间某个实例挂了怎么办？Eureka 内容有一个心跳检测机制，如果某个实例在规定的时间内没有进行通讯则会自动被剔除掉，避免了某个实例挂掉而影响服务。<br>因此使用了 Eureka 就自动具有了注册中心、负载均衡、故障转移的功能。</p>
<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>在微服务架构中通常存在多个服务层进行调用，当一个服务挂了以后容易导致整个系统都不可用，这也叫做服务器雪崩。<br>这种情况下需要有故障隔离功能，避免上面的问题发生，Hystrix 会在某个服务连续调用 N 次不响应的情况下，立即通知调用端调用失败，避免调用端持续等待而影响了整体服务。Hystrix 间隔时间会再次检查此服务，如果服务恢复将继续提供服务。</p>
<hr>
<p>服务容错保护Hystrix    中文含义是豪猪，寓意着保护自己不受天敌的伤害，代表一种防御机制<br>服务雪崩效应：<br>服务雪崩效应是一种因 服务提供者 的不可用导致 服务调用者 的不可用，并将不可用 逐渐放大 的过程<br><img src="SpringCloud%E4%B8%BB%E8%A6%81%E5%8C%85%E6%8B%AC%E4%BB%80%E4%B9%88/006tNc79ly1fqdrhznd6yj30ak0cyaep.jpg"><br>如上图所示：先是A服务不可用，而后调用A服务的B服务也不可用，最后是调用B服务的C/D服务也不可用，形成服务雪崩<br>服务雪崩主要有三个阶段：</p>
<ol>
<li>服务提供者不可用</li>
<li>重试加大流量</li>
<li>服务调用者不可用<h2 id="Hystrix-Dashboard-和-Turbine"><a href="#Hystrix-Dashboard-和-Turbine" class="headerlink" title="Hystrix Dashboard 和 Turbine"></a>Hystrix Dashboard 和 Turbine</h2>Hystrix Dashboard是一个针对Hystrix进行实时监控的工具，但是使用Hystrix Dashboard只能看到单个应用内的服务信息，我们需要一个汇总多个服务的数据显示的Hystrix Dashboard，这个工具就是Turbine<h2 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h2>随着服务的不断增多，每个微服务都应该对应着自己的配置文件。<br>Spring Cloud Config 是一个解决分布式系统的配置管理方案。它包含了 Client 和 Server 两个部分，Server 提供配置文件的存储、以接口的形式将配置文件的内容提供出去，Client 通过接口获取数据、并依据此数据初始化自己的应用。<h2 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h2>Spring Cloud Config是单个项目的配置中心，而bus则是将多个Config统一管理</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/01/SpringCloud%E4%B8%BB%E8%A6%81%E5%8C%85%E6%8B%AC%E4%BB%80%E4%B9%88/" data-id="ckejvvygs0008mjzxhwu23rrk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java8/">Java8</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis%E5%AD%A6%E4%B9%A0/">Redis学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java8/">java8</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java%E5%B7%A5%E5%85%B7%E7%B1%BB/">java工具类</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%91%BD%E4%BB%A4%E8%A1%8C/">命令行</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/">阿里巴巴代码规范</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/01/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/09/01/java8%E4%B8%AD%E7%9A%84%E6%B5%81%E5%BC%8F%E5%86%99%E6%B3%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/09/01/2020-08-24/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/09/01/FeginClient%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/09/01/Java8%E4%B8%ADMap.merge%E3%80%81compute%E3%80%81computeIfAbsent%E3%80%81computeIfPre/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>